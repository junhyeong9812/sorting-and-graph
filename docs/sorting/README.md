# 정렬 알고리즘 (Sorting Algorithms)

## 개요

정렬 알고리즘은 데이터를 특정 순서(오름차순/내림차순)로 재배열하는 알고리즘입니다.

## 알고리즘 목록

| 알고리즘 | 문서 | 시간복잡도 | 공간복잡도 |
|---------|------|-----------|-----------|
| 버블 정렬 | [bubble-sort.md](./bubble-sort.md) | O(n²) | O(1) |
| 선택 정렬 | [selection-sort.md](./selection-sort.md) | O(n²) | O(1) |
| 삽입 정렬 | [insertion-sort.md](./insertion-sort.md) | O(n²) | O(1) |
| 병합 정렬 | [merge-sort.md](./merge-sort.md) | O(n log n) | O(n) |
| 퀵 정렬 | [quick-sort.md](./quick-sort.md) | O(n log n) | O(log n) |
| 힙 정렬 | [heap-sort.md](./heap-sort.md) | O(n log n) | O(1) |

## 시간복잡도 & 공간복잡도란?

### 시간복잡도 (Time Complexity)
알고리즘이 실행되는 데 걸리는 시간을 입력 크기(n)의 함수로 표현한 것입니다.
```
O(1)       : 상수 시간 - 입력 크기와 무관하게 항상 같은 시간
O(log n)   : 로그 시간 - 입력이 커져도 느리게 증가 (이진 탐색)
O(n)       : 선형 시간 - 입력에 비례 (단순 반복)
O(n log n) : 선형 로그 - 효율적인 정렬 알고리즘
O(n²)      : 제곱 시간 - 중첩 반복문 (버블, 선택, 삽입)
O(2^n)     : 지수 시간 - 매우 느림 (피보나치 재귀)
```

**예시: 10,000개 데이터 정렬 시**
```
O(n²)      = 100,000,000 연산  → 느림
O(n log n) = 약 130,000 연산   → 빠름
```

### 공간복잡도 (Space Complexity)
알고리즘이 사용하는 메모리 양을 입력 크기(n)의 함수로 표현한 것입니다.
```
O(1)   : 추가 메모리 없음 (In-place) - 버블, 선택, 삽입, 힙
O(n)   : 입력 크기만큼 추가 메모리 - 병합 정렬
O(log n) : 재귀 스택 깊이 - 퀵 정렬
```

## 안정 정렬 vs 불안정 정렬

**안정 정렬 (Stable Sort)**
- 동일한 값의 원소들이 정렬 후에도 원래 순서를 유지
- 버블, 삽입, 병합 정렬

**불안정 정렬 (Unstable Sort)**
- 동일한 값의 원소들 순서가 바뀔 수 있음
- 선택, 퀵, 힙 정렬
```
예시: [(A,3), (B,1), (C,3), (D,2)] 를 숫자 기준 정렬

안정 정렬 결과:   [(B,1), (D,2), (A,3), (C,3)]  ← A가 C보다 앞 (원래 순서 유지)
불안정 정렬 결과: [(B,1), (D,2), (C,3), (A,3)]  ← 순서 바뀔 수 있음
```

## 알고리즘 선택 가이드

| 상황 | 추천 | 이유 |
|-----|------|-----|
| 데이터 50개 미만 | 삽입 정렬 | 오버헤드 적음 |
| 거의 정렬된 데이터 | 삽입 정렬 | O(n)에 가깝게 동작 |
| 메모리 제한 | 힙 정렬 | O(1) 공간 |
| 안정성 필요 | 병합 정렬 | 안정 + O(n log n) |
| 평균 성능 중요 | 퀵 정렬 | 가장 빠름 |
| 최악 성능 보장 | 병합/힙 정렬 | 항상 O(n log n) |
