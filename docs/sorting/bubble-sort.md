# 버블 정렬 (Bubble Sort)

## 요약

| 항목 | 내용 |
|-----|------|
| 시간복잡도 (최선) | O(n) - 이미 정렬된 경우 |
| 시간복잡도 (평균) | O(n²) |
| 시간복잡도 (최악) | O(n²) |
| 공간복잡도 | O(1) |
| 안정성 | 안정 정렬 |

## 원리

인접한 두 원소를 비교하여 순서가 잘못되어 있으면 교환합니다.
마치 거품(bubble)이 수면 위로 올라오듯이 큰 값이 배열 끝으로 이동합니다.

## 동작 과정
```
초기: [5, 3, 8, 4, 2]

1회전: 가장 큰 값(8)이 맨 뒤로
  [5, 3, 8, 4, 2]
   ↓
  [3, 5, 8, 4, 2]  (5 > 3, 교환)
   ↓
  [3, 5, 8, 4, 2]  (5 < 8, 유지)
   ↓
  [3, 5, 4, 8, 2]  (8 > 4, 교환)
   ↓
  [3, 5, 4, 2, 8]  (8 > 2, 교환) ← 8 확정

2회전: [3, 5, 4, 2, | 8]
  → [3, 4, 2, 5, | 8]  ← 5 확정

3회전: [3, 4, 2, | 5, 8]
  → [3, 2, 4, | 5, 8]  ← 4 확정

4회전: [3, 2, | 4, 5, 8]
  → [2, 3, | 4, 5, 8]  ← 완료

결과: [2, 3, 4, 5, 8]
```

## 코드
```java
public void sort(int[] arr) {
    int n = arr.length;
    boolean swapped;

    for (int i = 0; i < n - 1; i++) {
        swapped = false;

        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 교환
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }

        // 교환이 없었으면 이미 정렬 완료
        if (!swapped) break;
    }
}
```

## 특징

**장점**
- 구현이 가장 단순함
- 추가 메모리 불필요 (In-place)
- 안정 정렬

**단점**
- 매우 느림 (O(n²))
- 실무에서 거의 사용하지 않음

**사용 시기**
- 교육/학습 목적
- 데이터가 극소량일 때
- 거의 정렬된 데이터 (최적화 버전)
