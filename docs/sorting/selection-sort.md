# 선택 정렬 (Selection Sort)

## 요약

| 항목 | 내용 |
|-----|------|
| 시간복잡도 (최선) | O(n²) |
| 시간복잡도 (평균) | O(n²) |
| 시간복잡도 (최악) | O(n²) |
| 공간복잡도 | O(1) |
| 안정성 | 불안정 정렬 |

## 원리

배열에서 최솟값을 찾아 맨 앞과 교환하는 과정을 반복합니다.
매 단계마다 가장 작은 원소를 "선택"합니다.

## 동작 과정
```
초기: [5, 3, 8, 4, 2]

1회전: 전체에서 최솟값(2) 찾기
  [5, 3, 8, 4, 2]
              ↑ 최솟값
  [2, 3, 8, 4, 5]  (5와 2 교환)
   ↑ 확정

2회전: 나머지에서 최솟값(3) 찾기
  [2, | 3, 8, 4, 5]
       ↑ 이미 제자리
   ↑↑ 확정

3회전: 나머지에서 최솟값(4) 찾기
  [2, 3, | 8, 4, 5]
             ↑ 최솟값
  [2, 3, 4, 8, 5]  (8과 4 교환)

4회전: 나머지에서 최솟값(5) 찾기
  [2, 3, 4, | 8, 5]
                ↑ 최솟값
  [2, 3, 4, 5, 8]  (8과 5 교환)

결과: [2, 3, 4, 5, 8]
```

## 코드
```java
public void sort(int[] arr) {
    int n = arr.length;

    for (int i = 0; i < n - 1; i++) {
        // 최솟값 인덱스 찾기
        int minIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }

        // 교환
        if (minIdx != i) {
            int temp = arr[i];
            arr[i] = arr[minIdx];
            arr[minIdx] = temp;
        }
    }
}
```

## 특징

**장점**
- 구현이 단순함
- 교환 횟수가 O(n)으로 적음 (버블보다 적은 교환)
- 추가 메모리 불필요

**단점**
- 항상 O(n²) 비교 (최선도 O(n²))
- 불안정 정렬

**사용 시기**
- 교환 비용이 비교 비용보다 클 때
- 메모리 쓰기가 제한된 환경
